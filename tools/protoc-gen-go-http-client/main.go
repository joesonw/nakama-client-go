package main

import (
	_ "embed"
	"flag"
	"fmt"
	"net/http"
	"regexp"
	"strconv"
	"strings"

	"github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	pkgIO        = protogen.GoImportPath("io")
	pkgJSON      = protogen.GoImportPath("encoding/json")
	pkgBase64    = protogen.GoImportPath("encoding/base64")
	pkgHTTP      = protogen.GoImportPath("net/http")
	pkgContext   = protogen.GoImportPath("context")
	pkgBytes     = protogen.GoImportPath("bytes")
	pkgFmt       = protogen.GoImportPath("fmt")
	pkgURL       = protogen.GoImportPath("net/url")
	pkgHTTPUtil  = protogen.GoImportPath("github.com/joesonw/nakama-client-go/httputil")
	pkgGRPC      = protogen.GoImportPath("google.golang.org/grpc")
	pkgProtoJSON = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")

	pathParamRegexp = regexp.MustCompile(`\{\w+\}`)
)

//nolint:funlen,gocyclo
func main() {
	importRewriteFunc := func(importPath protogen.GoImportPath) protogen.GoImportPath {
		switch importPath {
		case "context", "fmt", "math":
			return importPath
		}
		return importPath
	}

	protogen.Options{
		ParamFunc:         flag.CommandLine.Set,
		ImportRewriteFunc: importRewriteFunc,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			g := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+".pb.http.go", f.GoImportPath)
			g2 := gen.NewGeneratedFile(f.GeneratedFilenamePrefix+".pb.http.interface.go", f.GoImportPath)
			g.P("// generated by protoc-gen-go-http-client. PLEASE DO NOT MODIFY")
			g.P("")
			g.P("package pb")
			g.P("")
			g2.P("// generated by protoc-gen-go-http-client. PLEASE DO NOT MODIFY")
			g2.P("")
			g2.P("package pb")
			g2.P("")
			for _, s := range f.Services {
				client := s.GoName + "Client"
				g.P("type ", client, " struct {")
				g.P("Client *", pkgHTTP.Ident("Client"))
				g.P("URL string")
				g.P("}")
				g.P("")

				g2.P("type ", client, "Interface interface {")

				for _, m := range s.Methods {
					r, ok := proto.GetExtension(m.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
					if !ok {
						continue
					}
					operation, _ := proto.GetExtension(m.Desc.Options(), options.E_Openapiv2Operation).(*options.Operation)

					rules := append(r.GetAdditionalBindings(), r)
					for i, rule := range rules {
						var method, path string
						switch v := rule.Pattern.(type) {
						case *annotations.HttpRule_Get:
							method = http.MethodGet
							path = v.Get
						case *annotations.HttpRule_Post:
							method = http.MethodPost
							path = v.Post
						case *annotations.HttpRule_Put:
							method = http.MethodPut
							path = v.Put
						case *annotations.HttpRule_Delete:
							method = http.MethodDelete
							path = v.Delete
						case *annotations.HttpRule_Patch:
							method = http.MethodPatch
							path = v.Patch
						}

						body := rule.GetBody()
						methodName := m.GoName
						if i > 0 {
							methodName += strconv.Itoa(i + 1)
						}

						g.P("func (c *", client, ") ", methodName, "(ctx ", pkgContext.Ident("Context"), ", req *", m.Input.GoIdent, ", opts ...", pkgGRPC.Ident("CallOption"), ") (*", m.Output.GoIdent, ", error) {")
						g.P("var body ", pkgIO.Ident("Reader"))
						g2.P(methodName, "(ctx ", pkgContext.Ident("Context"), ", req *", m.Input.GoIdent, ", opts ...", pkgGRPC.Ident("CallOption"), ") (*", m.Output.GoIdent, ", error)")

						pathParams := map[string]bool{}
						pathParamIndexes := pathParamRegexp.FindAllStringIndex(path, -1)
						if len(pathParamIndexes) > 0 {
							realPath := ""
							names := make([]string, len(pathParamIndexes))
							for ii, indexes := range pathParamIndexes {
								name := path[indexes[0]+1 : indexes[1]-1]
								pathParams[name] = true
								for _, field := range m.Input.Fields {
									if field.Desc.TextName() == name {
										names[ii] = fmt.Sprintf("req.%s", field.GoName)
									}
								}
								realPath += path[:indexes[0]] + "%v" + path[indexes[1]:]
							}
							g.P("path := ", pkgFmt.Ident("Sprintf("), strconv.Quote(realPath), ",", strings.Join(names, ","), ")")
						} else {
							g.P("path := ", strconv.Quote(path))
						}

						if body != "" {
							var fieldName string
							isMessage := false
							if body == "*" {
								isMessage = true
							} else {
								for _, field := range m.Input.Fields {
									if name := field.Desc.TextName(); name == body && !pathParams[name] {
										isMessage = field.Desc.Kind() == protoreflect.MessageKind
										fieldName = fmt.Sprintf(".Get%s()", field.GoName)
										break
									}
								}
							}
							if isMessage {
								g.P("reqBytes, err := ", pkgProtoJSON.Ident("Marshal"), "(req", fieldName, ")")
							} else {
								g.P("reqBytes, err := ", pkgJSON.Ident("Marshal"), "(req", fieldName, ")")
							}
							g.P("if err != nil {")
							g.P("return nil, err")
							g.P("}")
							g.P("body = ", pkgBytes.Ident("NewReader"), "(reqBytes)")
						}

						g.P("u, err := ", pkgURL.Ident("Parse"), "(c.URL + path)")
						g.P("if err != nil {")
						g.P("return nil, err")
						g.P("}")

						g.P("q:= &", pkgURL.Ident("Values"), "{}")
						if body != "*" && len(m.Input.Fields) > 0 {
							for _, field := range m.Input.Fields {
								if name := field.Desc.TextName(); name != body {
									if field.Desc.IsList() {
										g.P("for _, v := range req.", field.GoName, "{")
										if field.Desc.Kind() == protoreflect.StringKind {
											g.P("q.Add(", strconv.Quote(name), ", v)")
										} else {
											g.P("q.Add(", strconv.Quote(name), ", ", pkgFmt.Ident("Sprint"), "(v))")
										}
										g.P("}")
									} else {
										if field.Desc.Kind() == protoreflect.StringKind {
											g.P("q.Set(", strconv.Quote(name), ", req.", field.GoName, ")")
										} else if msg := field.Message; msg != nil && msg.GoIdent.GoImportPath == "google.golang.org/protobuf/types/known/wrapperspb" {
											g.P("if req.", field.GoName, " != nil {")
											g.P("q.Set(", strconv.Quote(name), ", ", pkgFmt.Ident("Sprint"), "(req.", field.GoName, ".GetValue()))")
											g.P("}")
										} else {
											g.P("q.Set(", strconv.Quote(name), ", ", pkgFmt.Ident("Sprint"), "(req.", field.GoName, "))")
										}
									}
								}
							}
						}
						for _, security := range operation.GetSecurity() {
							if _, ok := security.GetSecurityRequirement()["HttpKeyAuth"]; ok {
								g.P("q.Set(\"http_key\", ", pkgHTTPUtil.Ident("GetHTTPKeyAuth"), "(ctx))")
							}
						}
						g.P("u.RawQuery = q.Encode()")

						g.P("httpReq, err := ", pkgHTTP.Ident("NewRequestWithContext"), "(ctx, ", strconv.Quote(method), ", u.String(), body)")
						g.P("if err != nil {")
						g.P("return nil, err")
						g.P("}")
						g.P("httpReq = ", pkgHTTPUtil.Ident("AttachGRPCToRequest"), "(ctx, httpReq, opts...)")
						g.P("if body != nil {")
						g.P("httpReq.Header.Set(\"Content-Type\", \"application/json\")")
						g.P("}")

						for _, security := range operation.GetSecurity() {
							if _, ok := security.GetSecurityRequirement()["BasicAuth"]; ok {
								g.P("user, pass := ", pkgHTTPUtil.Ident("GetBasicAuth"), "(ctx)")
								g.P("httpReq.Header.Add(\"Authorization\",\"Basic \" + ", pkgBase64.Ident("StdEncoding"), ".EncodeToString([]byte(user+\":\"+pass)))")
							}
							if _, ok := security.GetSecurityRequirement()["BearerJwt"]; ok {
								g.P("httpReq.Header.Add(\"Authorization\", \"Bearer \" + ", pkgHTTPUtil.Ident("GetBearerJWT"), "(ctx))")
							}
						}
						if operation == nil {
							g.P("httpReq.Header.Add(\"Authorization\", \"Bearer \" + ", pkgHTTPUtil.Ident("GetBearerJWT"), "(ctx))")
						}

						g.P("httpRes, err := c.Client.Do(httpReq)")
						g.P("if err != nil {")
						g.P("return nil, err")
						g.P("}")
						g.P("if err := ", pkgHTTPUtil.Ident("CheckResponse"), "(ctx, httpRes); err != nil {")
						g.P("_ = httpRes.Body.Close()")
						g.P("return nil, err")
						g.P("}")
						g.P("httpRes = ", pkgHTTPUtil.Ident("RetrieveGRPCFromResponse"), "(ctx, httpRes, opts...)")
						g.P("resBytes, err := ", pkgIO.Ident("ReadAll"), "(httpRes.Body)")
						g.P("_ = httpRes.Body.Close()")
						g.P("if err != nil {")
						g.P("return nil, err")
						g.P("}")
						g.P("res := &", m.Output.GoIdent, "{}")
						g.P("err = ", pkgProtoJSON.Ident("Unmarshal"), "(resBytes, res)")
						g.P("if err != nil {")
						g.P("return nil, err")
						g.P("}")
						g.P("return res, nil")
						g.P("}")
						g.P("")
						_ = rule
					}
				}

				g2.P("}")
			}

			return nil
		}
		return nil
	})
}
