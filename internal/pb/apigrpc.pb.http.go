// generated by protoc-gen-go-http-client. PLEASE DO NOT MODIFY

package pb

import (
	bytes "bytes"
	context "context"
	base64 "encoding/base64"
	json "encoding/json"
	fmt "fmt"
	api "github.com/heroiclabs/nakama-common/api"
	httputil "github.com/joesonw/nakama-client-go/httputil"
	grpc "google.golang.org/grpc"
	protojson "google.golang.org/protobuf/encoding/protojson"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http "net/http"
	url "net/url"
)

type NakamaClient struct {
	Client *http.Client
	URL    string
}

func (c *NakamaClient) AddFriends(ctx context.Context, req *api.AddFriendsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/friend"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	for _, v := range req.Ids {
		q.Add("ids", v)
	}
	for _, v := range req.Usernames {
		q.Add("usernames", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AddGroupUsers(ctx context.Context, req *api.AddGroupUsersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v/add", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	for _, v := range req.UserIds {
		q.Add("user_ids", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) SessionRefresh(ctx context.Context, req *api.SessionRefreshRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/session/refresh"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) SessionLogout(ctx context.Context, req *api.SessionLogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/session/logout"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateApple(ctx context.Context, req *api.AuthenticateAppleRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/apple"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateCustom(ctx context.Context, req *api.AuthenticateCustomRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/custom"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateDevice(ctx context.Context, req *api.AuthenticateDeviceRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/device"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateEmail(ctx context.Context, req *api.AuthenticateEmailRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/email"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateFacebook(ctx context.Context, req *api.AuthenticateFacebookRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/facebook"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	if req.Sync != nil {
		q.Set("sync", fmt.Sprint(req.Sync.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateFacebookInstantGame(ctx context.Context, req *api.AuthenticateFacebookInstantGameRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/facebookinstantgame"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateGameCenter(ctx context.Context, req *api.AuthenticateGameCenterRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/gamecenter"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateGoogle(ctx context.Context, req *api.AuthenticateGoogleRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/google"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) AuthenticateSteam(ctx context.Context, req *api.AuthenticateSteamRequest, opts ...grpc.CallOption) (*api.Session, error) {
	var body io.Reader
	path := "/v2/account/authenticate/steam"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Create != nil {
		q.Set("create", fmt.Sprint(req.Create.GetValue()))
	}
	q.Set("username", req.Username)
	if req.Sync != nil {
		q.Set("sync", fmt.Sprint(req.Sync.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	user, pass := httputil.GetBasicAuth(ctx)
	httpReq.Header.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(user+":"+pass)))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Session{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) BanGroupUsers(ctx context.Context, req *api.BanGroupUsersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v/ban", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	for _, v := range req.UserIds {
		q.Add("user_ids", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) BlockFriends(ctx context.Context, req *api.BlockFriendsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/friend/block"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	for _, v := range req.Ids {
		q.Add("ids", v)
	}
	for _, v := range req.Usernames {
		q.Add("usernames", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) CreateGroup(ctx context.Context, req *api.CreateGroupRequest, opts ...grpc.CallOption) (*api.Group, error) {
	var body io.Reader
	path := "/v2/group"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Group{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) DeleteAccount(ctx context.Context, req *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) DeleteFriends(ctx context.Context, req *api.DeleteFriendsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/friend"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	for _, v := range req.Ids {
		q.Add("ids", v)
	}
	for _, v := range req.Usernames {
		q.Add("usernames", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) DeleteGroup(ctx context.Context, req *api.DeleteGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) DeleteLeaderboardRecord(ctx context.Context, req *api.DeleteLeaderboardRecordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/leaderboard/%v", req.LeaderboardId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("leaderboard_id", req.LeaderboardId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) DeleteNotifications(ctx context.Context, req *api.DeleteNotificationsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/notification"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	for _, v := range req.Ids {
		q.Add("ids", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) DeleteTournamentRecord(ctx context.Context, req *api.DeleteTournamentRecordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/tournament/%v", req.TournamentId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("tournament_id", req.TournamentId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) DeleteStorageObjects(ctx context.Context, req *api.DeleteStorageObjectsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/storage/delete"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "PUT", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) Event(ctx context.Context, req *api.Event, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/event"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) GetAccount(ctx context.Context, req *emptypb.Empty, opts ...grpc.CallOption) (*api.Account, error) {
	var body io.Reader
	path := "/v2/account"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Account{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) GetUsers(ctx context.Context, req *api.GetUsersRequest, opts ...grpc.CallOption) (*api.Users, error) {
	var body io.Reader
	path := "/v2/user"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	for _, v := range req.Ids {
		q.Add("ids", v)
	}
	for _, v := range req.Usernames {
		q.Add("usernames", v)
	}
	for _, v := range req.FacebookIds {
		q.Add("facebook_ids", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Users{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) GetSubscription(ctx context.Context, req *api.GetSubscriptionRequest, opts ...grpc.CallOption) (*api.ValidatedSubscription, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/iap/subscription/%v", req.ProductId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("product_id", req.ProductId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.ValidatedSubscription{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) Healthcheck(ctx context.Context, req *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/healthcheck"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ImportFacebookFriends(ctx context.Context, req *api.ImportFacebookFriendsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/friend/facebook"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Reset_ != nil {
		q.Set("reset", fmt.Sprint(req.Reset_.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ImportSteamFriends(ctx context.Context, req *api.ImportSteamFriendsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/friend/steam"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Reset_ != nil {
		q.Set("reset", fmt.Sprint(req.Reset_.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) JoinGroup(ctx context.Context, req *api.JoinGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v/join", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) JoinTournament(ctx context.Context, req *api.JoinTournamentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/tournament/%v/join", req.TournamentId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("tournament_id", req.TournamentId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) KickGroupUsers(ctx context.Context, req *api.KickGroupUsersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v/kick", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	for _, v := range req.UserIds {
		q.Add("user_ids", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LeaveGroup(ctx context.Context, req *api.LeaveGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v/leave", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkApple(ctx context.Context, req *api.AccountApple, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/apple"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkCustom(ctx context.Context, req *api.AccountCustom, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/custom"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkDevice(ctx context.Context, req *api.AccountDevice, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/device"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkEmail(ctx context.Context, req *api.AccountEmail, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/email"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkFacebook(ctx context.Context, req *api.LinkFacebookRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/facebook"
	reqBytes, err := protojson.Marshal(req.GetAccount())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Sync != nil {
		q.Set("sync", fmt.Sprint(req.Sync.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkFacebookInstantGame(ctx context.Context, req *api.AccountFacebookInstantGame, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/facebookinstantgame"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkGameCenter(ctx context.Context, req *api.AccountGameCenter, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/gamecenter"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkGoogle(ctx context.Context, req *api.AccountGoogle, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/google"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) LinkSteam(ctx context.Context, req *api.LinkSteamRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/link/steam"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListChannelMessages(ctx context.Context, req *api.ListChannelMessagesRequest, opts ...grpc.CallOption) (*api.ChannelMessageList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/channel/%v", req.ChannelId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("channel_id", req.ChannelId)
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	if req.Forward != nil {
		q.Set("forward", fmt.Sprint(req.Forward.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.ChannelMessageList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListFriends(ctx context.Context, req *api.ListFriendsRequest, opts ...grpc.CallOption) (*api.FriendList, error) {
	var body io.Reader
	path := "/v2/friend"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	if req.State != nil {
		q.Set("state", fmt.Sprint(req.State.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.FriendList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListGroups(ctx context.Context, req *api.ListGroupsRequest, opts ...grpc.CallOption) (*api.GroupList, error) {
	var body io.Reader
	path := "/v2/group"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("name", req.Name)
	q.Set("cursor", req.Cursor)
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("lang_tag", req.LangTag)
	if req.Members != nil {
		q.Set("members", fmt.Sprint(req.Members.GetValue()))
	}
	if req.Open != nil {
		q.Set("open", fmt.Sprint(req.Open.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.GroupList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListGroupUsers(ctx context.Context, req *api.ListGroupUsersRequest, opts ...grpc.CallOption) (*api.GroupUserList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v/user", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	if req.State != nil {
		q.Set("state", fmt.Sprint(req.State.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.GroupUserList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListLeaderboardRecords(ctx context.Context, req *api.ListLeaderboardRecordsRequest, opts ...grpc.CallOption) (*api.LeaderboardRecordList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/leaderboard/%v", req.LeaderboardId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("leaderboard_id", req.LeaderboardId)
	for _, v := range req.OwnerIds {
		q.Add("owner_ids", v)
	}
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	if req.Expiry != nil {
		q.Set("expiry", fmt.Sprint(req.Expiry.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.LeaderboardRecordList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListLeaderboardRecordsAroundOwner(ctx context.Context, req *api.ListLeaderboardRecordsAroundOwnerRequest, opts ...grpc.CallOption) (*api.LeaderboardRecordList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/leaderboard/%v/owner/{owner_id}/v2/leaderboard/{leaderboard_id}/owner/%v", req.LeaderboardId, req.OwnerId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("leaderboard_id", req.LeaderboardId)
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("owner_id", req.OwnerId)
	if req.Expiry != nil {
		q.Set("expiry", fmt.Sprint(req.Expiry.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.LeaderboardRecordList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListMatches(ctx context.Context, req *api.ListMatchesRequest, opts ...grpc.CallOption) (*api.MatchList, error) {
	var body io.Reader
	path := "/v2/match"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	if req.Authoritative != nil {
		q.Set("authoritative", fmt.Sprint(req.Authoritative.GetValue()))
	}
	if req.Label != nil {
		q.Set("label", fmt.Sprint(req.Label.GetValue()))
	}
	if req.MinSize != nil {
		q.Set("min_size", fmt.Sprint(req.MinSize.GetValue()))
	}
	if req.MaxSize != nil {
		q.Set("max_size", fmt.Sprint(req.MaxSize.GetValue()))
	}
	if req.Query != nil {
		q.Set("query", fmt.Sprint(req.Query.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.MatchList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListNotifications(ctx context.Context, req *api.ListNotificationsRequest, opts ...grpc.CallOption) (*api.NotificationList, error) {
	var body io.Reader
	path := "/v2/notification"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("cacheable_cursor", req.CacheableCursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.NotificationList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListStorageObjects(ctx context.Context, req *api.ListStorageObjectsRequest, opts ...grpc.CallOption) (*api.StorageObjectList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/storage/%v/{user_id}/v2/storage/{collection}/%v", req.Collection, req.UserId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("user_id", req.UserId)
	q.Set("collection", req.Collection)
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.StorageObjectList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListStorageObjects2(ctx context.Context, req *api.ListStorageObjectsRequest, opts ...grpc.CallOption) (*api.StorageObjectList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/storage/%v", req.Collection)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("user_id", req.UserId)
	q.Set("collection", req.Collection)
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.StorageObjectList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListSubscriptions(ctx context.Context, req *api.ListSubscriptionsRequest, opts ...grpc.CallOption) (*api.SubscriptionList, error) {
	var body io.Reader
	path := "/v2/iap/subscription"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.SubscriptionList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListTournaments(ctx context.Context, req *api.ListTournamentsRequest, opts ...grpc.CallOption) (*api.TournamentList, error) {
	var body io.Reader
	path := "/v2/tournament"
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	if req.CategoryStart != nil {
		q.Set("category_start", fmt.Sprint(req.CategoryStart.GetValue()))
	}
	if req.CategoryEnd != nil {
		q.Set("category_end", fmt.Sprint(req.CategoryEnd.GetValue()))
	}
	if req.StartTime != nil {
		q.Set("start_time", fmt.Sprint(req.StartTime.GetValue()))
	}
	if req.EndTime != nil {
		q.Set("end_time", fmt.Sprint(req.EndTime.GetValue()))
	}
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.TournamentList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListTournamentRecords(ctx context.Context, req *api.ListTournamentRecordsRequest, opts ...grpc.CallOption) (*api.TournamentRecordList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/tournament/%v", req.TournamentId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("tournament_id", req.TournamentId)
	for _, v := range req.OwnerIds {
		q.Add("owner_ids", v)
	}
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	if req.Expiry != nil {
		q.Set("expiry", fmt.Sprint(req.Expiry.GetValue()))
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.TournamentRecordList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListTournamentRecordsAroundOwner(ctx context.Context, req *api.ListTournamentRecordsAroundOwnerRequest, opts ...grpc.CallOption) (*api.TournamentRecordList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/tournament/%v/owner/{owner_id}/v2/tournament/{tournament_id}/owner/%v", req.TournamentId, req.OwnerId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("tournament_id", req.TournamentId)
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	q.Set("owner_id", req.OwnerId)
	if req.Expiry != nil {
		q.Set("expiry", fmt.Sprint(req.Expiry.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.TournamentRecordList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ListUserGroups(ctx context.Context, req *api.ListUserGroupsRequest, opts ...grpc.CallOption) (*api.UserGroupList, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/user/%v/group", req.UserId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("user_id", req.UserId)
	if req.Limit != nil {
		q.Set("limit", fmt.Sprint(req.Limit.GetValue()))
	}
	if req.State != nil {
		q.Set("state", fmt.Sprint(req.State.GetValue()))
	}
	q.Set("cursor", req.Cursor)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.UserGroupList{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) PromoteGroupUsers(ctx context.Context, req *api.PromoteGroupUsersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v/promote", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	for _, v := range req.UserIds {
		q.Add("user_ids", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) DemoteGroupUsers(ctx context.Context, req *api.DemoteGroupUsersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v/demote", req.GroupId)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("group_id", req.GroupId)
	for _, v := range req.UserIds {
		q.Add("user_ids", v)
	}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ReadStorageObjects(ctx context.Context, req *api.ReadStorageObjectsRequest, opts ...grpc.CallOption) (*api.StorageObjects, error) {
	var body io.Reader
	path := "/v2/storage"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.StorageObjects{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) RpcFunc(ctx context.Context, req *api.Rpc, opts ...grpc.CallOption) (*api.Rpc, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/rpc/%v", req.Id)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("id", req.Id)
	q.Set("payload", req.Payload)
	q.Set("http_key", req.HttpKey)
	q.Set("http_key", httputil.GetHTTPKeyAuth(ctx))
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Rpc{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) RpcFunc2(ctx context.Context, req *api.Rpc, opts ...grpc.CallOption) (*api.Rpc, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/rpc/%v", req.Id)
	reqBytes, err := json.Marshal(req.GetPayload())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("id", req.Id)
	q.Set("http_key", req.HttpKey)
	q.Set("http_key", httputil.GetHTTPKeyAuth(ctx))
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.Rpc{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkApple(ctx context.Context, req *api.AccountApple, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/apple"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkCustom(ctx context.Context, req *api.AccountCustom, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/custom"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkDevice(ctx context.Context, req *api.AccountDevice, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/device"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkEmail(ctx context.Context, req *api.AccountEmail, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/email"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkFacebook(ctx context.Context, req *api.AccountFacebook, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/facebook"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkFacebookInstantGame(ctx context.Context, req *api.AccountFacebookInstantGame, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/facebookinstantgame"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkGameCenter(ctx context.Context, req *api.AccountGameCenter, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/gamecenter"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkGoogle(ctx context.Context, req *api.AccountGoogle, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/google"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UnlinkSteam(ctx context.Context, req *api.AccountSteam, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account/unlink/steam"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UpdateAccount(ctx context.Context, req *api.UpdateAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := "/v2/account"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "PUT", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) UpdateGroup(ctx context.Context, req *api.UpdateGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/group/%v", req.GroupId)
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "PUT", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &emptypb.Empty{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ValidatePurchaseApple(ctx context.Context, req *api.ValidatePurchaseAppleRequest, opts ...grpc.CallOption) (*api.ValidatePurchaseResponse, error) {
	var body io.Reader
	path := "/v2/iap/purchase/apple"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.ValidatePurchaseResponse{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ValidateSubscriptionApple(ctx context.Context, req *api.ValidateSubscriptionAppleRequest, opts ...grpc.CallOption) (*api.ValidateSubscriptionResponse, error) {
	var body io.Reader
	path := "/v2/iap/subscription/apple"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.ValidateSubscriptionResponse{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ValidatePurchaseGoogle(ctx context.Context, req *api.ValidatePurchaseGoogleRequest, opts ...grpc.CallOption) (*api.ValidatePurchaseResponse, error) {
	var body io.Reader
	path := "/v2/iap/purchase/google"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.ValidatePurchaseResponse{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ValidateSubscriptionGoogle(ctx context.Context, req *api.ValidateSubscriptionGoogleRequest, opts ...grpc.CallOption) (*api.ValidateSubscriptionResponse, error) {
	var body io.Reader
	path := "/v2/iap/subscription/google"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.ValidateSubscriptionResponse{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ValidatePurchaseHuawei(ctx context.Context, req *api.ValidatePurchaseHuaweiRequest, opts ...grpc.CallOption) (*api.ValidatePurchaseResponse, error) {
	var body io.Reader
	path := "/v2/iap/purchase/huawei"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.ValidatePurchaseResponse{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) ValidatePurchaseFacebookInstant(ctx context.Context, req *api.ValidatePurchaseFacebookInstantRequest, opts ...grpc.CallOption) (*api.ValidatePurchaseResponse, error) {
	var body io.Reader
	path := "/v2/iap/purchase/facebookinstant"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.ValidatePurchaseResponse{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) WriteLeaderboardRecord(ctx context.Context, req *api.WriteLeaderboardRecordRequest, opts ...grpc.CallOption) (*api.LeaderboardRecord, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/leaderboard/%v", req.LeaderboardId)
	reqBytes, err := protojson.Marshal(req.GetRecord())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("leaderboard_id", req.LeaderboardId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.LeaderboardRecord{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) WriteStorageObjects(ctx context.Context, req *api.WriteStorageObjectsRequest, opts ...grpc.CallOption) (*api.StorageObjectAcks, error) {
	var body io.Reader
	path := "/v2/storage"
	reqBytes, err := protojson.Marshal(req)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "PUT", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.StorageObjectAcks{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) WriteTournamentRecord(ctx context.Context, req *api.WriteTournamentRecordRequest, opts ...grpc.CallOption) (*api.LeaderboardRecord, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/tournament/%v", req.TournamentId)
	reqBytes, err := protojson.Marshal(req.GetRecord())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("tournament_id", req.TournamentId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "POST", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.LeaderboardRecord{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (c *NakamaClient) WriteTournamentRecord2(ctx context.Context, req *api.WriteTournamentRecordRequest, opts ...grpc.CallOption) (*api.LeaderboardRecord, error) {
	var body io.Reader
	path := fmt.Sprintf("/v2/tournament/%v", req.TournamentId)
	reqBytes, err := protojson.Marshal(req.GetRecord())
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqBytes)
	u, err := url.Parse(c.URL + path)
	if err != nil {
		return nil, err
	}
	q := &url.Values{}
	q.Set("tournament_id", req.TournamentId)
	u.RawQuery = q.Encode()
	httpReq, err := http.NewRequestWithContext(ctx, "PUT", u.String(), body)
	if err != nil {
		return nil, err
	}
	httpReq = httputil.AttachGRPCToRequest(ctx, httpReq, opts...)
	if body != nil {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	httpReq.Header.Add("Authorization", "Bearer "+httputil.GetBearerJWT(ctx))
	httpRes, err := c.Client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	if err := httputil.CheckResponse(ctx, httpRes); err != nil {
		_ = httpRes.Body.Close()
		return nil, err
	}
	httpRes = httputil.RetrieveGRPCFromResponse(ctx, httpRes, opts...)
	resBytes, err := io.ReadAll(httpRes.Body)
	_ = httpRes.Body.Close()
	if err != nil {
		return nil, err
	}
	res := &api.LeaderboardRecord{}
	err = protojson.Unmarshal(resBytes, res)
	if err != nil {
		return nil, err
	}
	return res, nil
}
